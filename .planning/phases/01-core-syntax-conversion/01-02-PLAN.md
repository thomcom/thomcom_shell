---
phase: 01-core-syntax-conversion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tools/conda.sh
  - tools/kitty.sh
  - tools/fzf.sh
  - tools/atuin.sh
  - interactive/completion.sh
  - features/broadcast.sh
autonomous: true

must_haves:
  truths:
    - "All tools files renamed from .zsh to .sh"
    - "micromamba init uses --shell bash"
    - "atuin init uses bash"
    - "Completion uses bash-completion system"
    - "Broadcast uses bash trap syntax (placeholders for Phase 2)"
    - "fzf uses bash syntax for history widget"
  artifacts:
    - path: "tools/conda.sh"
      provides: "Micromamba initialization for bash"
      contains: "--shell bash"
    - path: "tools/atuin.sh"
      provides: "Atuin history for bash"
      contains: "atuin init bash"
    - path: "features/broadcast.sh"
      provides: "Broadcast system (partial - trap syntax in Phase 2)"
      contains: "#!/bin/bash"
  key_links:
    - from: "bashrc"
      to: "tools/conda.sh"
      via: "source_module"
      pattern: 'tools/conda'
---

<objective>
Convert complex tool integrations and features from zsh to bash syntax.

Purpose: Handle the heavy zsh-specific syntax in tools and features.
Output: 6 converted files ready for signal/hook work in Phase 2.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert tool initialization files</name>
  <files>
    tools/conda.sh
    tools/kitty.sh
    tools/atuin.sh
  </files>
  <action>
**tools/conda.zsh -> tools/conda.sh**
1. Change shebang: `#!/bin/zsh` -> `#!/bin/bash`
2. Change: `shell hook --shell zsh` -> `shell hook --shell bash`
3. Rest is bash-compatible

**tools/kitty.zsh -> tools/kitty.sh**
1. Change shebang: `#!/bin/zsh` -> `#!/bin/bash`
2. Change zsh-specific path expansion:
   - `${0:A:h}` (zsh: absolute path of script's directory) becomes:
   - `$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)` or
   - Store in variable at top: `SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"`
   - Use `$SCRIPT_DIR` instead of `${0:A:h}`
3. Line: `local thomcom_kitty_conf="${0:A:h}/kitty/kitty.conf"` becomes:
   - First get script dir: `local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"`
   - Then: `local thomcom_kitty_conf="$script_dir/kitty/kitty.conf"`

**tools/atuin.zsh -> tools/atuin.sh**
1. Change shebang: `#!/bin/zsh` -> `#!/bin/bash`
2. Change `return 0` to `return 0` (same)
3. Change: `eval "$(atuin init zsh)"` -> `eval "$(atuin init bash)"`
4. Change `[[ -o interactive ]]` -> `[[ $- == *i* ]]`
5. The fzf-atuin-history-widget function uses zsh line editor (zle):
   - `setopt localoptions...` -> REMOVE (bash doesn't have this)
   - `${(qqq)LBUFFER}` -> `${READLINE_LINE}` (bash equivalent of line buffer)
   - `LBUFFER="$selected"` -> `READLINE_LINE="$selected"; READLINE_POINT=${#READLINE_LINE}`
   - `zle reset-prompt` -> REMOVE (bash handles this differently)
   - `zle -N fzf-atuin-history-widget` -> REMOVE (not needed in bash)
   - `bindkey '^R' fzf-atuin-history-widget` -> `bind -x '"\C-r": fzf-atuin-history-widget'`
   - `bindkey '^E' _atuin_search_widget` -> `bind -x '"\C-e": _atuin_search_widget'`
  </action>
  <tests skip_tests="true">
    <skip_tests_reason>Tool integration config - verified by bash -n</skip_tests_reason>
  </tests>
  <verify>bash -n tools/conda.sh && bash -n tools/kitty.sh && bash -n tools/atuin.sh</verify>
  <done>Three tool files converted with bash syntax, init commands use --shell bash</done>
</task>

<task type="auto">
  <name>Task 2: Convert fzf, completion, and broadcast files</name>
  <files>
    tools/fzf.sh
    interactive/completion.sh
    features/broadcast.sh
  </files>
  <action>
**tools/fzf.zsh -> tools/fzf.sh**
1. Change shebang: `#!/bin/zsh` -> `#!/bin/bash`
2. Change `~/.fzf.zsh` -> `~/.fzf.bash`
3. Change `[[ -o interactive ]]` -> `[[ $- == *i* ]]`
4. Change `[[ -n "$ZSH_VERSION" ]]` -> REMOVE this block (was for zsh fallback)
5. Source paths: `/usr/share/doc/fzf/examples/completion.zsh` -> `completion.bash`
6. fzf-history-widget function conversion:
   - `setopt localoptions...` -> REMOVE
   - `${SHARED_HISTFILE:-$HOME/.zsh_history}` -> `${SHARED_HISTFILE:-$HOME/.bash_history}`
   - `LBUFFER="$selected"` -> `READLINE_LINE="$selected"; READLINE_POINT=${#READLINE_LINE}`
   - `zle reset-prompt` -> REMOVE
   - `zle -N fzf-history-widget` -> REMOVE
   - `${(qqq)LBUFFER}` -> `"${READLINE_LINE}"` (bash quoting)
7. At end, instead of `zle -N`:
   - `bind -x '"\C-r": fzf-history-widget'` (but only if atuin not available)

**interactive/completion.zsh -> interactive/completion.sh**
1. Change shebang: `#!/bin/zsh` -> `#!/bin/bash`
2. Change `[[ ! -o interactive ]]` -> `[[ $- != *i* ]]`
3. REMOVE zsh completion system entirely:
   - REMOVE `zstyle :compinstall filename "$HOME/.zshrc"`
   - REMOVE `autoload -Uz compinit`
   - REMOVE `compinit`
4. REPLACE with bash-completion:
   ```bash
   # Initialize bash completion
   if [[ -f /etc/bash_completion ]]; then
       source /etc/bash_completion
   elif [[ -f /usr/share/bash-completion/bash_completion ]]; then
       source /usr/share/bash-completion/bash_completion
   fi
   ```
5. Keep `bindkey -v` -> `set -o vi` (but vi mode already in options.sh, can remove)
6. Kubernetes completion:
   - `source <(kubectl completion zsh)` -> `source <(kubectl completion bash)`
   - REMOVE `compdef _kubectl k` (bash doesn't use compdef)
   - ADD: `complete -F __start_kubectl k` (bash way to alias completion)

**features/broadcast.zsh -> features/broadcast.sh**
1. Change shebang: `#!/bin/zsh` -> `#!/bin/bash`
2. Change broadcast directory: `~/.zsh_broadcasts` -> `~/.bash_broadcasts`
3. Change state file: `~/.zsh_broadcast_state_$$` -> `~/.bash_broadcast_state_$$`
4. Convert nullglob handling:
   - `setopt NULL_GLOB` -> `shopt -s nullglob`
   - `unsetopt NULL_GLOB` -> `shopt -u nullglob`
5. Function existence checks (Phase 2 will refine, but stub it):
   - `(( ${+functions[precmd]} ))` -> `declare -f precmd >/dev/null 2>&1`
   - `functions[_orig_precmd]=${functions[precmd]}` -> `eval "_orig_precmd() { $(declare -f precmd | tail -n +2) }"`
6. TRAPUSR1 and TRAPEXIT (Phase 2 will implement properly, stub for now):
   - `TRAPUSR1() { ... }` -> `# TODO Phase 2: trap '_check_broadcasts' USR1`
   - `TRAPEXIT() { ... }` -> `# TODO Phase 2: trap '_cleanup_broadcast_state' EXIT`
7. precmd hook (Phase 2 will implement via PROMPT_COMMAND, stub for now):
   - Comment out the precmd-related code with `# TODO Phase 2: PROMPT_COMMAND`
8. zbc function - change pkill target:
   - `pkill -USR1 -x "zsh"` -> `pkill -USR1 -x "bash"`
9. History array check:
   - `(( ${#history[@]} % 10 == 0 ))` -> This references zsh's $history array
   - Replace with: `(( HISTCMD % 10 == 0 ))` or just call every time (simpler)

Note: Signal handlers (TRAPUSR1, TRAPEXIT) and precmd require bash-specific trap syntax.
Mark these with TODO comments for Phase 2 - this plan focuses on syntax, not behavior.
  </action>
  <tests skip_tests="true">
    <skip_tests_reason>Tool/feature config - verified by bash -n, behavior tested in Phase 4</skip_tests_reason>
  </tests>
  <verify>bash -n tools/fzf.sh && bash -n interactive/completion.sh && bash -n features/broadcast.sh</verify>
  <done>Three complex files converted, pass bash -n, signal handlers stubbed for Phase 2</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All 6 files pass `bash -n`
2. `grep -r "setopt\|zle\|bindkey\|compdef\|compinit" tools/*.sh interactive/completion.sh` returns empty (no zsh constructs)
3. `grep "init bash" tools/atuin.sh` confirms atuin uses bash
4. `grep "shell bash" tools/conda.sh` confirms micromamba uses bash
</verification>

<success_criteria>
- 6 new .sh files exist with bash syntax
- Tool initializations use `--shell bash` or `init bash`
- No zsh-specific constructs remain (except TODOs for Phase 2)
- All files pass `bash -n` syntax check
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-syntax-conversion/01-02-SUMMARY.md`
</output>
